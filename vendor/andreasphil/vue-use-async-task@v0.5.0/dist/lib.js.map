{
  "version": 3,
  "sources": ["../src/lib.ts"],
  "sourcesContent": ["import { computed, ref, type Ref } from \"vue\";\n\n// For more information about InferArgs and InferReturn see:\n// https://fettblog.eu/variadic-tuple-types-preview/\n\n/** Returns the parameters of a generic function T */\nexport type InferArgs<T> = T extends (...t: [...infer Params]) => any\n  ? Params\n  : never;\n\n/** Returns the return value of a generic function T */\nexport type InferReturn<T> = T extends (...t: any) => infer Return\n  ? Return\n  : never;\n\n/**\n * Returns a wrapper for an asynchronous function that keeps track of the\n * loading state, errors, and return value of the function.\n */\nexport function useAsyncTask<\n  F extends (...args: any[]) => Promise<any>,\n  E = any\n>(\n  /** Function that performs an async task */\n  fetcher: F,\n  /**\n   * If provided, will use existing reactive variables for storing state\n   * instead of creating new ones. Useful e.g. for sharing the `isLoading`\n   * state between multiple async tasks.\n   */\n  shared?: {\n    isLoading?: Ref<boolean>;\n    error?: Ref<E | undefined>;\n  }\n) {\n  // Shorthands for the various types we need\n  type FetcherArgs = InferArgs<F>;\n  type FetcherReturn = Awaited<InferReturn<F>> | undefined;\n  type RunnerReturn = [FetcherReturn, undefined] | [undefined, E];\n\n  // State\n  const data = ref<FetcherReturn>();\n  const isLoading = shared?.isLoading ?? ref(false);\n  const error = shared?.error ?? ref<E | undefined>(undefined);\n  const hasError = computed(() => !!error.value);\n\n  const run = async (...args: FetcherArgs): Promise<RunnerReturn> => {\n    isLoading.value = true;\n    error.value = undefined;\n\n    try {\n      const result = await fetcher(...args);\n      data.value = result;\n      return [result, undefined];\n    } catch (e: any) {\n      error.value = e;\n      return [undefined, e];\n    } finally {\n      isLoading.value = false;\n    }\n  };\n\n  return {\n    /**\n     * Executes the task and updates all the state properties. Returns a tuple\n     * of the shape `[data, error]` that contains the result of the task. If\n     * the task succeeded, `data` will be set to the return value (if one\n     * exists), `error` will be undefined. If the task threw, `data` will be\n     * undefined and `error` will be set to the value that was thrown. Note\n     * that `run` itself never throws, so you don't need to catch anything.\n     *\n     * Example:\n     *\n     * ```\n     * const { run } = useAsyncTask(myTask);\n     * const [data, error] = await run();\n     * if (error) {\n     *   // Handle error here\n     * } else {\n     *   // Do something with data here\n     * }\n     * ```\n     */\n    run,\n    /** Return value of the task */\n    data,\n    /** True while the task is running */\n    isLoading,\n    /** Will receive the exception thrown by the task if one occurs */\n    error,\n    /** True if an exception has been thrown */\n    hasError,\n  };\n}\n"],
  "mappings": "AAAA,OAAS,YAAAA,EAAU,OAAAC,MAAqB,MAmBjC,SAASC,EAKdC,EAMAC,EAIA,CAOA,IAAMC,EAAOJ,EAAmB,EAC1BK,EAAYF,GAAQ,WAAaH,EAAI,EAAK,EAC1CM,EAAQH,GAAQ,OAASH,EAAmB,MAAS,EACrDO,EAAWR,EAAS,IAAM,CAAC,CAACO,EAAM,KAAK,EAkB7C,MAAO,CAqBL,IArCU,SAAUE,IAA6C,CACjEH,EAAU,MAAQ,GAClBC,EAAM,MAAQ,OAEd,GAAI,CACF,IAAMG,EAAS,MAAMP,EAAQ,GAAGM,CAAI,EACpC,OAAAJ,EAAK,MAAQK,EACN,CAACA,EAAQ,MAAS,CAC3B,OAAS,EAAQ,CACf,OAAAH,EAAM,MAAQ,EACP,CAAC,OAAW,CAAC,CACtB,QAAE,CACAD,EAAU,MAAQ,EACpB,CACF,EAyBE,KAAAD,EAEA,UAAAC,EAEA,MAAAC,EAEA,SAAAC,CACF,CACF",
  "names": ["computed", "ref", "useAsyncTask", "fetcher", "shared", "data", "isLoading", "error", "hasError", "args", "result"]
}
